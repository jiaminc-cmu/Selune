# Selune Performance Report

> Auto-generated by `benchmarks/run_benchmarks.sh` on 2026-02-24 16:40:31
> To regenerate: `./benchmarks/run_benchmarks.sh`

# Selune Benchmark Results

**Date:** 2026-02-24 16:40:31
**Machine:** arm64 Apple M3
**OS:** macOS 14.5
**Runs per benchmark:** 5 (best of N)

### Implementations

- **Selune:** ./target/release/selune
- **PUC Lua:** Lua 5.4.8  Copyright (C) 1994-2025 Lua.org, PUC-Rio
- **LuaJIT:** LuaJIT 2.1.1767980792 -- Copyright (C) 2005-2026 Mike Pall. https://luajit.org/

---

## Results

| Benchmark | Selune (s) | PUC Lua (s) | LuaJIT (s) | Selune/PUC | Selune/LuaJIT |
|-----------|-----------|-------------|------------|------------|---------------|
| arithmetic | 9.862995 | 3.100396 | 0.236286 | 3.18x | 41.74x |
| fibonacci | 2.876726 | 0.733333 | 0.068000 | 3.92x | 42.30x |
| ackermann | 16.401121 | 7.158334 | 0.834154 | 2.29x | 19.66x |
| table_array | 0.225528 | 0.090576 | 0.009193 | 2.49x | 24.53x |
| table_hash | 2.151582 | 1.629705 | 0.372412 | 1.32x | 5.78x |
| table_object | 1.338735 | 0.385736 | 0.076914 | 3.47x | 17.41x |
| string_concat | 0.340675 | 0.207476 | 0.092558 | 1.64x | 3.68x |
| string_match | 0.111248 | 0.013378 | 0.010777 | 8.32x | 10.32x |
| string_format | 1.755913 | 0.692899 | 0.216839 | 2.53x | 8.10x |
| closures | 0.718148 | 0.371798 | 0.207367 | 1.93x | 3.46x |
| method_calls | 5.315438 | 0.828490 | 0.088708 | 6.42x | 59.92x |
| coroutines | 0.820905 | 0.231927 | SKIP | 3.54x | — |
| gc_pressure | 1.147372 | 0.839387 | 0.118103 | 1.37x | 9.72x |
| binary_trees | 3.258369 | 2.826967 | 0.708041 | 1.15x | 4.60x |
| spectral_norm | 8.546889 | 3.067507 | 0.057297 | 2.79x | 149.17x |
| mandelbrot | 2.905323 | 1.336816 | 0.112114 | 2.17x | 25.91x |

---

**Legend:**
- **Selune/PUC**: ratio of Selune time to PUC Lua time (lower is better for Selune; <1.0x means Selune is faster)
- **Selune/LuaJIT**: ratio of Selune time to LuaJIT time (lower is better for Selune)
- **SKIP**: benchmark not applicable for that implementation
- **FAIL**: benchmark failed to run

## Summary

- **Geometric mean Selune/PUC Lua:** 2.61x (across 16 benchmarks)
- **Geometric mean Selune/LuaJIT:** 15.79x (across 15 benchmarks)


---

## Analysis

### Category Breakdown

| Category | Benchmarks | Notes |
|----------|-----------|-------|
| Arithmetic/Loops | arithmetic, fibonacci, ackermann | Core dispatch loop + integer/float ops |
| Tables | table_array, table_hash, table_object | Array vs hash performance, metatable dispatch |
| Strings | string_concat, string_match, string_format | String interning, pattern engine, formatting |
| Functions | closures, method_calls | Closure creation, upvalue access, OOP dispatch |
| Coroutines | coroutines | Yield/resume overhead (Selune vs PUC only) |
| GC | gc_pressure, binary_trees | Allocation rate, GC pause time, tree traversal |
| Math | spectral_norm, mandelbrot | Float-heavy tight loops |

### Optimizations Applied

**Phase 3.5 interpreter performance work (3.27x → 2.61x geo mean):**

| Optimization | Impact | Details |
|-------------|--------|---------|
| Pattern engine: fixed-size capture array | string_match 78x → 8.5x | Eliminated heap allocs in hot backtrack loop |
| Pattern engine: zero-copy gmatch | string_match 8.5x → current | Two-phase borrow-match-intern avoids 450KB clones |
| Inline arithmetic fast paths | mandelbrot 6.6x → 2.2x | Integer+float checks directly in dispatch, bypass arith_op() |
| Inline comparison fast paths | mandelbrot, spectral_norm | Lt/Le/Eq with direct integer/float compare |
| Coroutine state swap | coroutines 6.4x → 3.5x | std::mem::swap instead of Vec clone on resume/yield |
| Pre-flatten protos | closures 2.7x → 1.9x | Proto tree pre-walked, closure uses flat index |
| Local PC variable | arithmetic 3.6x → 3.2x | Cache pc in local, write back at sync points |
| Shrink CallInfo | ~5% across the board | 120→80 bytes per frame, packed boolean flags |
| Table access: skip metamethods | table_array 3.0x → 2.5x | GetI/SetI/GetField/SetField skip chain when no metatable |
| Self_ fast path | method_calls ~7% | Raw lookup + one-level __index table check |
| Method dispatch: string key fast path | table ops ~5% | raw_get_str() bypasses boxed-int/float checks |
| Eliminate get_k clone | minor | Direct &constant reference instead of clone |

### Remaining Optimization Opportunities

**Interpreter-level (diminishing returns):**
- Inline caching for method calls and table lookups
- Register allocation improvements in the compiler
- Further ForLoop specialization

**JIT (next phase):**
- JIT compilation via Cranelift (selune-jit crate) — expected 5-50x on numeric benchmarks
- Type-specialized native code eliminates all dispatch and type-check overhead
- Inline caching at JIT level for method dispatch

**GC:**
- Generational GC (selune-core) — would improve gc_pressure and binary_trees

### How to Profile

#### Using Instruments (macOS)
```bash
# Time Profiler
xcrun xctrace record --template 'Time Profiler' --launch ./target/release/selune benchmarks/scripts/fibonacci.lua
```

#### Using cargo-flamegraph
```bash
cargo install flamegraph
cargo flamegraph --release -- benchmarks/scripts/fibonacci.lua
```

#### Using perf (Linux)
```bash
perf record -g ./target/release/selune benchmarks/scripts/fibonacci.lua
perf report
```

